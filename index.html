<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <title>(HW64 analyze tool by steve_gong)</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xlsx/dist/xlsx.full.min.js"></script>
    <!-- Excel export with embedded image -->
    <script src="https://cdn.jsdelivr.net/npm/exceljs/dist/exceljs.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/file-saver@2.0.5/dist/FileSaver.min.js"></script>
    <style>
      body {
        font-family: sans-serif;
        padding: 20px;
      }
      #sensorCheckboxes {
        max-height: 220px;
        overflow-y: auto;
        border: 1px solid #ccc;
        padding: 10px;
        width: 360px;
      }
      #chart {
        margin-top: 20px;
      }
      #statsPanel div strong {
        display: inline-block;
        min-width: 220px;
      }
      .controls {
        display: flex;
        gap: 8px;
        margin: 6px 0 12px;
        flex-wrap: wrap;
      }
      .help {
        color: #666;
        font-size: 12px;
        margin: 4px 0 10px;
      }
    </style>
  </head>
  <body>
    <h2>載入檔案</h2>
    <input type="file" id="fileInput" />

    <h2>選擇 Sensor</h2>
    <div class="controls">
      <button onclick="selectAllSensors()">全選</button>
      <button onclick="deselectAllSensors()">全取消</button>
      <button onclick="selectDefaults()">預設</button>
      <button onclick="clearChart()">清除圖表</button>
      <button onclick="exportXLSX()">輸出文件</button>
    </div>
    <div id="sensorCheckboxes"></div>

    <h2>篩選</h2>
    <div class="help">兩格都輸入數字(HW64預設1格為2000ms)</div>
    起始：<input type="text" id="startTime" placeholder="例如：100" />
    結束：<input type="text" id="endTime" placeholder="例如：350" />

    <h2>圖表</h2>
    <canvas id="chart" width="1000" height="460"></canvas>

    <h2>統計資訊</h2>
    <div id="statsPanel"></div>

    <script>
      // ------ Config ------
      const DUAL_AXIS_THRESHOLD = 8; // 啟用右軸的量級差距門檻

      // ------ State ------
      let timeValues = [];
      let sensorNames = [];
      let sensorData = {};
      let chart = null;

      document
        .getElementById("fileInput")
        .addEventListener("change", handleFile);
      document.getElementById("startTime").addEventListener("input", drawChart);
      document.getElementById("endTime").addEventListener("input", drawChart);

      // 清除圖表
      function clearChart() {
        if (chart) {
          chart.destroy();
          chart = null;
        }
        document.getElementById("statsPanel").innerHTML = "";
      }

      // 讀檔 & 解析 (SheetJS for parsing)
      function handleFile(e) {
        const file = e.target.files[0];
        if (!file) return;
        const ext = file.name.split(".").pop().toLowerCase();
        const reader = new FileReader();

        reader.onload = function (evt) {
          let rows;

          if (ext === "csv") {
            // 用 XLSX 正確解析 CSV（處理引號/逗號/分號/CRLF/BOM）
            let text = String(evt.target.result).replace(/^\uFEFF/, "");
            const wb = XLSX.read(text, { type: "string" });
            const sheet = wb.Sheets[wb.SheetNames[0]];
            rows = XLSX.utils.sheet_to_json(sheet, {
              header: 1,
              raw: false,
              defval: "",
            });
          } else {
            const data = new Uint8Array(evt.target.result);
            const workbook = XLSX.read(data, { type: "array" });
            const sheet = workbook.Sheets[workbook.SheetNames[0]];
            rows = XLSX.utils.sheet_to_json(sheet, { header: 1, defval: "" });
          }

          // 第一列表頭；尾端如有重複表頭移除
          rows = rows.filter((r) => Array.isArray(r) && r.length > 0);
          const header = rows[0].map((h) =>
            typeof h === "string" ? h.replace(/^\uFEFF/, "").trim() : h
          );
          let dataRows = rows.slice(1);
          for (let i = 0; i < 2; i++) {
            const tail = dataRows[dataRows.length - 1];
            if (tail && header.every((h, idx) => tail[idx] === h))
              dataRows.pop();
          }

          // 找時間欄（找不到用 B 欄）
          let timeColIndex = header.findIndex(
            (h) => typeof h === "string" && h.toLowerCase().includes("time")
          );
          if (timeColIndex === -1) timeColIndex = 1;

          // 感測器從 time 右一欄開始（安全回退 C 欄）
          let sensorStartIndex = timeColIndex + 1;
          if (!Number.isInteger(sensorStartIndex) || sensorStartIndex < 2)
            sensorStartIndex = 2;

          timeValues = dataRows.map((row) => row[timeColIndex]);
          sensorNames = header.slice(sensorStartIndex);

          sensorData = {};
          sensorNames.forEach((name, i) => {
            sensorData[name] = dataRows.map((row) => {
              const v = parseFloat(row[sensorStartIndex + i]);
              return isNaN(v) ? null : v;
            });
          });

          renderSensorOptions(true); // 初次渲染，套用預設勾選
        };

        if (ext === "csv") reader.readAsText(file, "UTF-8");
        else reader.readAsArrayBuffer(file);
      }

      // 預設勾選規則（含 GPU）
      function isDefaultSelected(name) {
        const s = String(name).trim();
        return (
          /cpu\s*package/i.test(s) || // CPU package
          /package\s*power/i.test(s) || // package power
          /temp\s*\d/i.test(s) || // temp0~9
          /^other\s*\(docking\)\s*\[rpm\]$/i.test(s) || // Other (Docking) [RPM]
          /gpu\s*temp/i.test(s) || // GPU temp*
          /gpu\s*power/i.test(s) // GPU power*
        );
      }

      // 建立感測器勾選清單
      function renderSensorOptions(applyDefaults = false) {
        const container = document.getElementById("sensorCheckboxes");
        container.innerHTML = "";
        sensorNames.forEach((name) => {
          const label = document.createElement("label");
          label.style.display = "block";
          const checkbox = document.createElement("input");
          checkbox.type = "checkbox";
          checkbox.value = name;
          checkbox.checked = applyDefaults ? isDefaultSelected(name) : false;
          checkbox.addEventListener("change", drawChart);
          label.appendChild(checkbox);
          label.appendChild(document.createTextNode(" " + name));
          container.appendChild(label);
        });
        if (applyDefaults) drawChart();
      }

      function getSelectedSensors() {
        return Array.from(
          document.querySelectorAll("#sensorCheckboxes input[type='checkbox']")
        )
          .filter((cb) => cb.checked)
          .map((cb) => cb.value);
      }

      function selectAllSensors() {
        document
          .querySelectorAll("#sensorCheckboxes input[type='checkbox']")
          .forEach((cb) => {
            cb.checked = true;
          });
        drawChart();
      }
      function deselectAllSensors() {
        document
          .querySelectorAll("#sensorCheckboxes input[type='checkbox']")
          .forEach((cb) => {
            cb.checked = false;
          });
        drawChart();
      }
      function selectDefaults() {
        document
          .querySelectorAll("#sensorCheckboxes input[type='checkbox']")
          .forEach((cb) => {
            cb.checked = isDefaultSelected(cb.value);
          });
        drawChart();
      }

      // 色彩（依索引固定不同色）
      function getColorByIndex(index) {
        const hue = (index * 47) % 360;
        return `hsl(${hue}, 70%, 50%)`;
      }

      // 統計 / 軸分配
      function seriesStats(arr) {
        const vals = arr.filter((v) => v !== null && Number.isFinite(v));
        if (!vals.length)
          return { min: null, max: null, maxAbs: 0, count: 0, avg: null };
        const min = Math.min(...vals);
        const max = Math.max(...vals);
        const sum = vals.reduce((a, b) => a + b, 0);
        const avg = sum / vals.length;
        const maxAbs = Math.max(Math.abs(min), Math.abs(max));
        return { min, max, maxAbs, count: vals.length, avg };
      }
      function median(nums) {
        const a = nums.slice().sort((x, y) => x - y);
        const n = a.length;
        if (!n) return 0;
        const mid = Math.floor(n / 2);
        return n % 2 ? a[mid] : (a[mid - 1] + a[mid]) / 2;
      }
      function decideAxisByScale(maxAbsArray, threshold = DUAL_AXIS_THRESHOLD) {
        const med = median(
          maxAbsArray.filter((x) => Number.isFinite(x) && x > 0)
        );
        if (!med) return maxAbsArray.map(() => "y");
        const maxOfAll = Math.max(...maxAbsArray);
        if (maxOfAll / med < threshold) return maxAbsArray.map(() => "y");
        return maxAbsArray.map((v) => (v >= med * threshold ? "y1" : "y"));
      }

      // ✅ 只有「兩個都輸入數字」才啟動數值模式（列序）
      function computeRangeIndices() {
        const startInput = document.getElementById("startTime").value.trim();
        const endInput = document.getElementById("endTime").value.trim();

        const isNum = (s) => /^\d+$/.test(s); // 正整數列序（A2=1, A3=2, ...）
        const bothNumeric = isNum(startInput) && isNum(endInput);

        let startIdx = 0;
        let endIdx = timeValues.length - 1;

        if (bothNumeric) {
          let s = parseInt(startInput, 10);
          let e = parseInt(endInput, 10);
          if (s > e) [s, e] = [e, s];
          startIdx = Math.max(0, Math.min(timeValues.length - 1, s - 1));
          endIdx = Math.max(0, Math.min(timeValues.length - 1, e - 1));
        } else {
          if (startInput) {
            const idx = timeValues.findIndex((t) => String(t) >= startInput);
            if (idx !== -1) startIdx = idx;
          }
          if (endInput) {
            const idx = timeValues.findIndex((t) => String(t) > endInput);
            if (idx !== -1) endIdx = idx - 1;
          }
        }

        if (endIdx < startIdx) endIdx = startIdx;
        return { startIdx, endIdx };
      }

      // 繪圖
      function drawChart() {
        const selectedSensors = getSelectedSensors();
        if (!selectedSensors.length || !timeValues.length) return;

        const { startIdx, endIdx } = computeRangeIndices();

        // X 軸列序 (A2=1, A3=2, ...)
        const labels = Array.from(
          { length: endIdx - startIdx + 1 },
          (_, i) => startIdx + i + 1
        );

        // 計算軸分配
        const slicedSeries = selectedSensors.map((name) =>
          (sensorData[name] || []).slice(startIdx, endIdx + 1)
        );
        const stats = slicedSeries.map(seriesStats);
        const maxAbsArray = stats.map((s) => s.maxAbs);
        const axes = decideAxisByScale(maxAbsArray, DUAL_AXIS_THRESHOLD);

        const datasets = selectedSensors.map((name, i) => ({
          label: name,
          data: slicedSeries[i],
          borderColor: getColorByIndex(i),
          fill: false,
          spanGaps: true,
          yAxisID: axes[i],
        }));

        const ctx = document.getElementById("chart").getContext("2d");
        if (chart) chart.destroy();
        chart = new Chart(ctx, {
          type: "line",
          data: { labels, datasets },
          options: {
            responsive: true,
            interaction: { mode: "index", intersect: false },
            scales: {
              x: { title: { display: true, text: "time(S)" } },
              y: {
                type: "linear",
                position: "left",
                title: { display: true, text: "Value (Left)" },
              },
              y1: {
                type: "linear",
                display: axes.includes("y1"),
                position: "right",
                title: { display: axes.includes("y1"), text: "Value (Right)" },
                grid: { drawOnChartArea: false },
              },
            },
            plugins: {
              legend: { position: "top" },
              tooltip: {
                callbacks: {
                  label: (ctx) => {
                    const axis =
                      ctx.dataset.yAxisID === "y1" ? " (Right)" : " (Left)";
                    return `${ctx.dataset.label}${axis}: ${ctx.formattedValue}`;
                  },
                },
              },
            },
          },
        });

        // 統計資訊
        const statsPanel = document.getElementById("statsPanel");
        statsPanel.innerHTML = "";
        selectedSensors.forEach((name, i) => {
          const vals = slicedSeries[i].filter((v) => v !== null);
          if (!vals.length) return;
          const max = Math.max(...vals);
          const min = Math.min(...vals);
          const avg = (vals.reduce((a, b) => a + b, 0) / vals.length).toFixed(
            2
          );
          const axisTag = axes[i] === "y1" ? "Right" : "Left";
          statsPanel.innerHTML += `<div><strong style="color:${getColorByIndex(
            i
          )}">${name} (${axisTag})</strong> ➤ MAX: ${max}, MIN: ${min}, AVG: ${avg}</div>`;
        });
      }

      // ====== 輸出 XLSX：含 Data / Stats / Chart(嵌入目前圖表 PNG) ======
      async function exportXLSX() {
        const selectedSensors = getSelectedSensors();
        if (!selectedSensors.length || !timeValues.length) {
          alert("請先載入資料並勾選至少一項欄位。");
          return;
        }

        const { startIdx, endIdx } = computeRangeIndices();

        // 準備 Data sheet：Row + 勾選欄位
        const headerRow = ["Row", ...selectedSensors];
        const dataSheetRows = [headerRow];
        const rowCount = endIdx - startIdx + 1;
        for (let r = 0; r < rowCount; r++) {
          const rowLabel = startIdx + r + 1; // A2=1
          const rowValues = selectedSensors.map((name) => {
            const v = sensorData[name][startIdx + r];
            return v === null || Number.isNaN(v) ? "" : v;
          });
          dataSheetRows.push([rowLabel, ...rowValues]);
        }

        // 準備 Stats sheet：Name, Axis, Max, Min, Avg, Count
        const slicedSeries = selectedSensors.map((name) =>
          (sensorData[name] || []).slice(startIdx, endIdx + 1)
        );
        const stats = slicedSeries.map(seriesStats);
        const maxAbsArray = stats.map((s) => s.maxAbs);
        const axes = decideAxisByScale(maxAbsArray, DUAL_AXIS_THRESHOLD);

        const statsHeader = ["Name", "Axis", "Max", "Min", "Avg", "Count"];
        const statsRows = [statsHeader];
        selectedSensors.forEach((name, i) => {
          const s = stats[i];
          const axisTag = axes[i] === "y1" ? "Right" : "Left";
          const avg =
            s.avg === null || s.avg === undefined ? "" : +s.avg.toFixed(4);
          statsRows.push([
            name,
            axisTag,
            s.max === null ? "" : s.max,
            s.min === null ? "" : s.min,
            avg,
            s.count || 0,
          ]);
        });

        // 建立 ExcelJS 工作簿
        const wb = new ExcelJS.Workbook();

        // Data
        const wsData = wb.addWorksheet("Data");
        dataSheetRows.forEach((row) => wsData.addRow(row));
        wsData.getRow(1).font = { bold: true };
        wsData.columns = headerRow.map(() => ({ width: 14 }));

        // Stats
        const wsStats = wb.addWorksheet("Stats");
        statsRows.forEach((row) => wsStats.addRow(row));
        wsStats.getRow(1).font = { bold: true };
        wsStats.columns = statsHeader.map(() => ({ width: 16 }));

        // Chart image (from current Chart.js canvas), if exists
        if (chart) {
          // get dataURL (PNG)
          const dataUrl = chart.toBase64Image("image/png", 1.0);
          const base64 = dataUrl.split(",")[1]; // ExcelJS expects pure base64 string

          const imageId = wb.addImage({
            base64: base64,
            extension: "png",
          });

          const wsChart = wb.addWorksheet("Chart");
          // Put image at top-left, size ~ canvas size
          const widthPx = 1000; // match your canvas width
          const heightPx = 460; // match your canvas height
          wsChart.addImage(imageId, {
            tl: { col: 0, row: 0 },
            ext: { width: widthPx, height: heightPx },
          });
          wsChart.getCell("A1").value = "Chart exported from current view";
          wsChart.getCell("A1").font = { bold: true };
        }

        // Save file
        const ts = new Date();
        const pad = (n) => String(n).padStart(2, "0");
        const fname = `export_${ts.getFullYear()}${pad(ts.getMonth() + 1)}${pad(
          ts.getDate()
        )}_${pad(ts.getHours())}${pad(ts.getMinutes())}${pad(
          ts.getSeconds()
        )}.xlsx`;

        const buf = await wb.xlsx.writeBuffer();
        saveAs(
          new Blob([buf], {
            type: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
          }),
          fname
        );
      }
    </script>
  </body>
</html>
